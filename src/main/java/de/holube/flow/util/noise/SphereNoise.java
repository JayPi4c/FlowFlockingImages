package de.holube.flow.util.noise;

import lombok.AccessLevel;
import lombok.NoArgsConstructor;

@NoArgsConstructor(access = AccessLevel.PRIVATE)
public class SphereNoise {

    /**
     * Returns a noise value between 0 and 1. This is generated by using 3D noise. It puts a sphere at the given
     * position (x, y, z). It then maps the coordinates of the rectangle to the sphere and returns the noise value.
     *
     * @param seed   The seed for the noise.
     * @param xR     The x coordinate on the rectangle.
     * @param yR     The y coordinate on the rectangle.
     * @param x      The x coordinate of the sphere.
     * @param y      The y coordinate of the sphere.
     * @param z      The z coordinate of the sphere.
     * @param radius The radius of the sphere.
     * @return A noise value between 0 and 1.
     */
    public static float noise(long seed, float xR, float yR, float xSize, float ySize, float x, float y, float z, float radius) {
        if (radius <= 0) {
            return 0;
        }

        float xRScaled = xR / xSize;
        float yRScaled = yR / ySize;

        float theta = (float) (xRScaled / (radius * Math.cos(0)));
        float phi = (yRScaled / radius);

        return noise(seed, radius, theta, phi, x, y, z);
    }

    public static float noise(long seed, float rho, float theta, float phi, float x, float y, float z) {
        if (rho <= 0) {
            return 0;
        }

        float xPos = toRectangularX(rho, theta, phi) + x;
        float yPos = toRectangularY(rho, theta, phi) + y;
        float zPos = toRectangularZ(rho, phi) + z;

        return OpenSimplex2S.noise3_ImproveXY(seed, xPos, yPos, zPos);
    }

    public static float toRectangularX(float rho, float theta, float phi) {
        return (float) (rho * Math.sin(phi) * Math.cos(theta));
    }

    public static float toRectangularY(float rho, float theta, float phi) {
        return (float) (rho * Math.sin(phi) * Math.sin(theta));
    }

    public static float toRectangularZ(float rho, float phi) {
        return (float) (rho * Math.cos(phi));
    }

}
